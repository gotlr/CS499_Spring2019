LMSquareLossIterations <-
  function(X.mat, y.vec, max.iterations, step.size = 0.5) {
    if (!all(is.matrix(X.mat), is.numeric(X.mat))) {
      stop("X.mat must be a numeric matrix.")
    }

    if (!all(is.vector(y.vec),
             is.numeric(y.vec),
             length(y.vec) == nrow(X.mat))) {
      stop("y.vec must be a numeric vector of the same number of rows as X.mat.")
    }

    if (!all(is.integer(max.iterations),
             max.iterations > 1,
             length(max.iterations) == 1)) {
      stop("Input max.iterations must be a greater than 1 integer scalar number.")
    }

    if (!all(is.numeric(step.size), length(step.size) == 1)) {
      stop("step.size must be a numeric scalar value.")
    }

    X.mat <- X.mat[,-1]
    #Obatin X.scaled.mat from the orginal X.mat, to make sure std = 1, u = 0
    num.train <- dim(X.mat)[1]
    num.feature <- dim(X.mat)[2]

    X.mean.vec <- colMeans(X.mat)

    X.std.vec <-
      sqrt(colSums((X.mat - X.mean.vec) ^ 2) / num.train)
    X.std.mat <- diag(num.feature) * (1 / X.std.vec)

    X.scaled.mat <- (t(X.mat) - X.mean.vec) / X.std.vec
    slope.mat <-
      matrix(c(
        rep(0, num.feature * max.iterations),
        num.feature,
        max.iterations
      ))

    # for-loop to get the slope.mat matrix
    for (iter.index in (1:max.iterations)) {
      if (iter.index == 1) {
        mean.loss.temp.vec <- (2 * t(X.scaled.mat) %*%
                                 (X.scaled.mat %*% slope.mat[, 1])) / num.train
        slope.vec.temp <-
          slope.mat[, 1] - step.size * mean.loss.temp.vec
      } else{
        mean.loss.temp.vec <- (2 * t(X.scaled.mat) %*%
                                 (X.scaled.mat %*% slope.mat[, iter.index - 1])) / num.train
        slope.vec.temp <-
          slope.mat[, iter.index - 1] - step.size * mean.loss.temp.vec
      }
      slope.mat[, iter.index] = slope.vec.temp

    }
    itercept <- -t(slope.mat) %*% X.std.mat %*% X.mean.vec #m x 1
    slope <- t(slope.mat) %*% X.std.mat  #m x (p-1)
    W.mat <- rbind(t(itercept), t(slope)) #p x m
    return(W.mat)
  }








LMLogisticLossIterations <-
  function(X.mat, y.vec,max.iterations, step.size = 0.05) {
    if (!all(is.matrix(X.mat), is.numeric(X.mat))) {
      stop("X.mat must be a numeric matrix.")
    }

    if (!all(is.vector(y.vec),
             is.numeric(y.vec),
             length(y.vec) == nrow(X.mat))) {
      stop("y.vec must be a numeric vector of the same number of rows as X.mat.")
    }

    if (!all(is.integer(max.iterations),
             max.iterations > 1,
             length(max.iterations) == 1)) {
      stop("Input max.iterations must be a greater than 1 integer scalar number.")
    }

    if (!all(is.numeric(step.size), length(step.size) == 1)) {
      stop("step.size must be a numeric scalar value.")
    }
    num.train <- dim(X.mat)[1]
    num.feature <- dim(X.mat)[2]
    W <- rep(0, ncol(X.mat))
    sigmoid <- function(z) { 1 / (1 + exp(-z))}
    X.scale.vec <- scale(X.mat,center=TRUE,scale = TRUE)[1:num.train,1:num.feature]#variance=1,mean=0
    W.mat=matrix(0,ncol=max.iterations,nrow=num.feature)
    for (i in 1:max.iterations){
      grad <- t(X.scale.vec) %*% (sigmoid(X.scale.vec %*% W)-y.vec);
      if (sqrt(as.numeric(t(grad) %*% grad)) < 1e-8){
        print(sprintf('iter times=%d', i));
        break;
      }
      W <- W - grad * step.size;
      W.mat[,i]=W
    }
    return(W.mat)
  }
